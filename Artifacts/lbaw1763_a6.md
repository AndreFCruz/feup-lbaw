# A6: Indices, triggers, user functions and population
SegFault is a collaborative platform for programmers to learn, discuss different approaches, present ideas and share knowledge in a Q&A style.

To this end, the following sections provide detailed insight into the inner workings of the project's database. The first section depicts the expected workload on the system, the second section specifies and explains the proposed indices to the database, and the third section comprises the database's triggers.

## 1. Database Workload

> A study of the predicted system load (database load), organized in subsections.

### 1.1. Tuple Estimation

> Estimate of tuples at each relation.


| Relation reference | Relation Name | Order of magnitude        | Estimated growth |
| ------------------ | ------------- | ------------------------- | ---------------- |
| R01                | Table1        | units|dozens|hundreds|etc | order per time   |
| R02                | Table2        | units|dozens|hundreds|etc | dozens per month |
| R03                | Table3        | units|dozens|hundreds|etc | hundreds per day |
| R04                | Table4        | units|dozens|hundreds|etc | no growth        |


### 1.2. Frequent Queries

> Most important queries (SELECT) and their frequency.

| Query reference   | SELECT01                               |
| Query description | One sentence describing the query goal |
| Query frequency   | magnitude per time                     |
| ----------------- | -------------------------------------- |
| SQL code                                                   |


### 1.3. Frequent Updates

> Most important updates (INSERT, UPDATE, DELETE) and their frequency.

| Query reference   | UPDATE01                               |
| Query description | One sentence describing the query goal |
| Query frequency   | magnitude per time                     |
| ----------------- | -------------------------------------- |
| SQL code                                                   |


## 2. Proposed Indices
This section presents the proposed indices on the database. It is important to note that many indices, mainly on high cardinality, would theoretically be better off being implemented as hash indices. We purposefuly did not choose these, because the PostgreSQL documentation actively discourages the usage of hash indices, as seen on the warning below.

![Hash Indices - Caution](https://i.imgur.com/XsIFTcY.png)


### 2.1. Performance Indices

|                 |                                                     |
| --------------- | --------------------------------------------------- |
| Index reference | IDX01                                               |
| Related queries | SELECT01                                            |
| Index relation  | comment                                             |
| Index attribute | commentable_id                                      |
| Index type      | B-tree                                              |
| Cardinality     | medium                                              |
| Clustering      | yes                                                 |
| Justification   | The Table is very large, and query SELECT01 must run efficiently as it is executed several times. It doesn't need range query support, and is a good candidate for clustering as its cardinality is medium. |
```sql
CREATE INDEX comment_commentable ON comment USING btree(commentable_id);
```
(This index could be implemented as a hash index, but, as explained in this section's introduction, this is actively discouraged.)

|                 |                                                     |
| --------------- | --------------------------------------------------- |
| Index reference | IDX02                                               |
| Related queries | SELECT01, SELECT02, SELECT04, SELECT06, SELECT07    |
| Index relation  | message_version                                     |
| Index attribute | message_id                                          |
| Index type      | B-tree                                              |
| Cardinality     | medium                                              |
| Clustering      | yes                                                 |
| Justification   | The Table is very large, and the corresponding queries are abundant and recurrent, thus must run efficiently. It doesn't need range query support, and is a good candidate for clustering as its cardinality is medium. |
```sql
CREATE INDEX message_version_message ON message_version USING btree(message_id);
```




### 2.2. Full-text Search Indices

| Index reference | IDX01                                               |
| Related queries | SELECT01, ...                                       |
| Index relation  | Relation where the index is applied                 |
| Index attribute | Attribute where the index is applied                |
| Index type      | B-tree, Hash, GiST or GIN                           |
| Clustering      | Clustering of the index                             |
| Justification   | Justification for the proposed index                |


### 2.3. Contraint-enforcing Indices



## 3. Triggers

> User-defined functions and trigger procedures that add control structures to the SQL language or perform complex computations, are identified and described to be trusted by the database server. Every kind of function (SQL functions, Stored procedures, Trigger procedures) can take base types, composite types, or combinations of these as arguments (parameters). In addition, every kind of function can return a base type or a composite type. Functions can also be defined to return sets of base or composite values.

| Trigger reference   | TRIGGER01                                                               |
| Trigger description | A message is banned if the amount of reports exceeds the limit define in BR08 |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION ban_message() RETURNS TRIGGER AS $$
    BEGIN
      UPDATE message
        SET is_banned = TRUE
        WHERE NEW.id = message.id;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER ban_message
    AFTER UPDATE OF num_reports ON message
    FOR EACH ROW
      WHEN ( NEW.num_reports >= 5 + NEW.score^(1/3) )
        EXECUTE PROCEDURE ban_message();
```

| Trigger reference   | TRIGGER02                                                               |
| Trigger description | An answer can only be marked as correct if it's an answer of that question |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION check_correct() RETURNS TRIGGER AS $$
    BEGIN
      IF NEW.correct_answer IS NOT NULL AND
        NOT EXISTS (SELECT * FROM answer WHERE NEW.correct_answer = id AND NEW.id = question_id) THEN
          RAISE EXCEPTION 'An answer can only be marked as correct if it is an answer of the question';
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER check_correct
    BEFORE UPDATE OF correct_answer ON question
    FOR EACH ROW EXECUTE PROCEDURE check_correct();
```

| Trigger reference   | TRIGGER03                                                               |
| Trigger description | A question must have between 1 and 5 categories |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION check_categories() RETURNS TRIGGER AS $$
    DECLARE num_categories SMALLINT;
    DECLARE current RECORD;
    BEGIN
        IF TG_OP = 'INSERT' THEN
          current = NEW;
        ELSE
          current = OLD;
        END IF;
        SELECT INTO num_categories count(*)
        FROM question_category
        WHERE current.question_id = question_category.question_id;
      IF num_categories > 5 THEN
        RAISE EXCEPTION 'A question can only have a maximum of 5 categories';
      ELSIF num_categories < 1 THEN
        RAISE EXCEPTION 'A question must have at least 1 category';
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER check_categories
    AFTER INSERT OR DELETE ON question_category
    FOR EACH ROW EXECUTE PROCEDURE check_categories();
```

| Trigger reference   | TRIGGER04                                                               |
| Trigger description | Update the number of posts a category is tagged in when another one is inserted |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION insert_category() RETURNS TRIGGER AS $$
    BEGIN
      UPDATE category
        SET num_posts = num_posts + 1
        WHERE NEW.category_id = category.id;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER insert_category
    AFTER INSERT ON question_category
    FOR EACH ROW EXECUTE PROCEDURE insert_category();
```

| Trigger reference   | TRIGGER05                                                               |
| Trigger description | Update the message's score once a vote is modified |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION update_score_vote() RETURNS TRIGGER AS $$
    BEGIN
      IF NEW.positive AND NOT OLD.positive THEN
        UPDATE message
          SET score = score + 2
          WHERE NEW.message_id = message.id;
      ELSIF NOT NEW.positive AND OLD.positive THEN
        UPDATE message
          SET score = score - 2
          WHERE NEW.message_id = message.id;
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER update_score_vote
    BEFORE UPDATE ON Vote
    FOR EACH ROW EXECUTE PROCEDURE update_score_vote();
```

| Trigger reference   | TRIGGER06                                                               |
| Trigger description | Update the message's score once a vote is inserted |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION insert_score_vote() RETURNS TRIGGER AS $$
    BEGIN
      IF NEW.positive THEN
        UPDATE message
          SET score = score + 1
          WHERE NEW.message_id = message.id;
      ELSIF NOT NEW.positive THEN
        UPDATE message
          SET score = score - 1
          WHERE NEW.message_id = message.id;
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER insert_score_vote
    BEFORE INSERT ON Vote
    FOR EACH ROW EXECUTE PROCEDURE insert_score_vote();
```

| Trigger reference   | TRIGGER07                                                               |
| Trigger description | Update the message's score once a vote is deleted |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION delete_score_vote() RETURNS TRIGGER AS $$
    BEGIN
      IF OLD.positive THEN
        UPDATE message
          SET score = score - 1
          WHERE OLD.message_id = message.id;
      ELSIF NOT OLD.positive THEN
        UPDATE message
          SET score = score + 1
          WHERE OLD.message_id = message.id;
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER delete_score_vote
    BEFORE DELETE ON Vote
    FOR EACH ROW EXECUTE PROCEDURE delete_score_vote();
```

| Trigger reference   | TRIGGER08                                                               |
| Trigger description | Update a user's reputation when one of its messages is reported as defined in BR03 |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION update_reputation_reports() RETURNS TRIGGER AS $$
    BEGIN
      UPDATE "user"
        SET reputation = reputation - (NEW.num_reports - OLD.num_reports)*10
        WHERE NEW.author = "user".id;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER update_reputation_reports
    BEFORE UPDATE OF num_reports ON message
    FOR EACH ROW EXECUTE PROCEDURE update_reputation_reports();
```

| Trigger reference   | TRIGGER09                                                               |
| Trigger description | Update a user's reputation when one of its messages is voted by another user as defined in BR03 |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION update_reputation_scores() RETURNS TRIGGER AS $$
    BEGIN
      IF EXISTS (SELECT * FROM commentable WHERE NEW.id = commentable.id) THEN
        UPDATE "user"
          SET reputation = reputation + (NEW.score - OLD.score)
          WHERE NEW.author = "user".id;
      ELSIF EXISTS (SELECT * FROM comment WHERE NEW.id = comment.id) THEN
        UPDATE "user"
          SET reputation = reputation + (NEW.score - OLD.score)/2.0
          WHERE NEW.author = "user".id;
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER update_reputation_scores
    BEFORE UPDATE OF score ON message
    FOR EACH ROW EXECUTE PROCEDURE update_reputation_scores();
```

| Trigger reference   | TRIGGER10                                                               |
| Trigger description | A user is awarded a "trusted" badge when they've correctly answered at least 50 questions |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION award_trusted() RETURNS TRIGGER AS $$
    DECLARE answer_author BIGINT;
    DECLARE trusted_id SMALLINT;
    DECLARE num_correct_answers INTEGER;
    BEGIN
      SELECT INTO answer_author author
        FROM message
        WHERE message.id = NEW.correct_answer;
      SELECT INTO trusted_id id FROM trusted_badge;
      IF NOT EXISTS
        (SELECT *
          FROM badge_attainment
          WHERE answer_author = badge_attainment.user_id AND trusted_id = badge_attainment.badge_id)
      THEN
        SELECT INTO num_correct_answers count(*)
          FROM message, question
          WHERE message.id = question.correct_answer AND message.author = answer_author;
        IF num_correct_answers >= 50 THEN
          INSERT INTO badge_attainment (user_id, badge_id) VALUES (answer_author, trusted_id);
        END IF;
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER award_trusted
    AFTER UPDATE OF correct_answer ON question
    FOR EACH ROW EXECUTE PROCEDURE award_trusted();
```

| Trigger reference   | TRIGGER11                                                               |
| Trigger description | A user is awarded a "moderator" badge when they've been awarded the "trusted" badge and then achieved at least 500 reputation points |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION award_moderator_reputation() RETURNS TRIGGER AS $$
    DECLARE moderator_id SMALLINT;
    DECLARE trusted_id SMALLINT;
    BEGIN
      SELECT INTO moderator_id id FROM moderator_badge;
      SELECT INTO trusted_id id FROM trusted_badge;
      IF NOT EXISTS
        (SELECT *
          FROM badge_attainment
          WHERE NEW.id = badge_attainment.user_id AND moderator_id = badge_attainment.badge_id)
        AND EXISTS
        (SELECT *
          FROM badge_attainment
          WHERE NEW.id = badge_attainment.user_id AND trusted_id = badge_attainment.badge_id)
        AND NEW.reputation >= 500 THEN
          INSERT INTO badge_attainment (user_id, badge_id) VALUES (NEW.id, moderator_id);
          INSERT INTO moderator (id) VALUES (NEW.id);
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER award_moderator_reputation
    AFTER UPDATE OF reputation ON "user"
    FOR EACH ROW EXECUTE PROCEDURE award_moderator_reputation();
```

| Trigger reference   | TRIGGER12                                                               |
| Trigger description | A user is awarded a "moderator" badge when they've achieved at least 500 reputation points and then were awarded the "trusted" badge |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION award_moderator_trusted() RETURNS TRIGGER AS $$
    DECLARE moderator_id SMALLINT;
    DECLARE trusted_id SMALLINT;
    DECLARE rep REAL;
    BEGIN
      SELECT INTO moderator_id id FROM moderator_badge;
      SELECT INTO trusted_id id FROM trusted_badge;
      SELECT INTO rep reputation FROM "user" WHERE "user".id = NEW.user_id;
      IF NEW.badge_id = trusted_id
      AND NOT EXISTS
        (SELECT *
          FROM badge_attainment
          WHERE NEW.user_id = badge_attainment.user_id AND moderator_id = badge_attainment.badge_id)
        AND rep >= 500 THEN
          INSERT INTO badge_attainment (user_id, badge_id) VALUES (NEW.user_id, moderator_id);
          INSERT INTO moderator (id) VALUES (NEW.user_id);
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER award_moderator_trusted
    AFTER INSERT ON badge_attainment
    FOR EACH ROW EXECUTE PROCEDURE award_moderator_trusted();
```

| Trigger reference   | TRIGGER13                                                               |
| Trigger description | A user can't vote their own messages as stated in BR02 |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION check_own_vote() RETURNS TRIGGER AS $$
    DECLARE message_author BIGINT;
    BEGIN
      SELECT INTO message_author author
        FROM message
        WHERE message.id = NEW.message_id;
      IF message_author = NEW.user_id THEN
        RAISE EXCEPTION 'A user is not allowed to vote their own messages';
      END IF;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER check_own_vote
    BEFORE INSERT ON Vote
    FOR EACH ROW EXECUTE PROCEDURE check_own_vote();
```

| Trigger reference   | TRIGGER14                                                               |
| Trigger description | Update the number of reports in a message when one is made to it |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION insert_report() RETURNS TRIGGER AS $$
    BEGIN
      UPDATE message
        SET num_reports = num_reports + 1
        WHERE NEW.message_id = message.id;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER insert_report
    BEFORE INSERT ON report
    FOR EACH ROW EXECUTE PROCEDURE insert_report();
```

| Trigger reference   | TRIGGER15                                                               |
| Trigger description | Update the number of reports in a message when one is removed |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION delete_report() RETURNS TRIGGER AS $$
    BEGIN
      UPDATE message
        SET num_reports = num_reports - 1
        WHERE NEW.message_id = message.id;
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER delete_report
    BEFORE DELETE ON report
    FOR EACH ROW EXECUTE PROCEDURE delete_report();
```

| Trigger reference   | TRIGGER16                                                               |
| Trigger description | A comment made to commentable item generates a notification towards the author of said commentable item |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION gen_comment_notification() RETURNS TRIGGER AS $$
    DECLARE current_id BIGINT;
    DECLARE notified_user BIGINT;
    BEGIN
      SELECT INTO current_id nextval(pg_get_serial_sequence('notification', 'id'));
      SELECT INTO notified_user author FROM message WHERE message.id = NEW.commentable_id;
      INSERT INTO notification (id, user_id) VALUES (current_id, notified_user);
      INSERT INTO commentable_notification (id, notified_msg, trigger_msg) VALUES (current_id, NEW.commentable_id, NEW.id);
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER gen_comment_notification
    AFTER INSERT ON comment
    FOR EACH ROW EXECUTE PROCEDURE gen_comment_notification();
```

| Trigger reference   | TRIGGER17                                                               |
| Trigger description | An answer to a question generates a notification towards the author of the question |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION gen_answer_notification() RETURNS TRIGGER AS $$
    DECLARE current_id BIGINT;
    DECLARE notified_user BIGINT;
    BEGIN
      SELECT INTO current_id nextval(pg_get_serial_sequence('notification', 'id'));
      SELECT INTO notified_user author FROM message WHERE message.id = NEW.question_id;
      INSERT INTO notification (id, user_id) VALUES (current_id, notified_user);
      INSERT INTO commentable_notification (id, notified_msg, trigger_msg) VALUES (current_id, NEW.question_id, NEW.id);
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER gen_answer_notification
    AFTER INSERT ON answer
    FOR EACH ROW EXECUTE PROCEDURE gen_answer_notification();
```

| Trigger reference   | TRIGGER18                                                               |
| Trigger description | When a badge is awarded to a user a notification to that user is generated |
| ------------------- | ----------------------------------------------------------------------- |
```sql
  CREATE FUNCTION gen_badge_notification() RETURNS TRIGGER AS $$
    DECLARE current_id BIGINT;
    BEGIN
      SELECT INTO current_id nextval(pg_get_serial_sequence('notification', 'id'));
      INSERT INTO notification (id, user_id) VALUES (current_id, NEW.user_id);
      INSERT INTO badge_notification (id, badge_id) VALUES (current_id, NEW.badge_id);
      RETURN NEW;
    END;
  $$ LANGUAGE plpgsql;

  CREATE TRIGGER gen_badge_notification
    AFTER INSERT ON badge_attainment
    FOR EACH ROW EXECUTE PROCEDURE gen_badge_notification();
```


## 4. Complete SQL Code

> The database script must also include the SQL to populate a database with test data with an amount of tuples suitable for testing and with plausible values for the fields of the database.
> This code should also be included in the group's github repository as an SQL script, and a link include here.


## Revision history

Changes made to the first submission:
1. Item 1
1. Item 2

***

GROUP1763, 03/04/2018

> André Cruz, up201503776@fe.up.pt  
> Daniel Marques, up201503822@fe.up.pt  
> Edgar Carneiro, up201503784@fe.up.pt  
> João Carvalho, up201504875@fe.up.pt  
